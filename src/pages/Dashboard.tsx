import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { useAuth } from "@/hooks/use-auth";
import { api } from "@/convex/_generated/api";
import { useMutation, useQuery } from "convex/react";
import { motion } from "framer-motion";
import { 
  CloudRain, 
  Droplets, 
  Leaf, 
  MapPin, 
  Mic, 
  MicOff, 
  TrendingUp, 
  Wheat,
  Globe,
  Volume2
} from "lucide-react";
import { Loader2 } from "lucide-react";
import { useEffect, useState } from "react";
import { toast } from "sonner";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import WeatherCard from "./dashboard/WeatherCard";
import MarketPricesCard from "./dashboard/MarketPricesCard";
import RecommendationsList from "./dashboard/RecommendationsList";

function deriveWeatherFromLocation(loc: string): { temperature: number; humidity: number; rainfall: number; forecast: string; localTime: string } {
  // Fallback if API fails; keep lightweight variability by hash
  let hash = 0;
  for (let i = 0; i < loc.length; i++) hash = (hash * 31 + loc.charCodeAt(i)) >>> 0;
  const now = new Date();
  const temp = 18 + (hash % 17);
  const humidity = 40 + (hash % 51);
  const rainfall = hash % 25;
  const forecasts = [
    "Partly cloudy with light breeze",
    "Sunny intervals with gentle winds",
    "Scattered showers possible",
    "Humid and overcast",
    "Clear skies and dry",
    "Thunderstorms likely in the evening",
  ];
  const forecast = forecasts[hash % forecasts.length];
  return { temperature: temp, humidity, rainfall, forecast, localTime: now.toLocaleString() };
}

async function fetchWeather(lat: number, lon: number) {
  const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,precipitation&timezone=auto`;
  const res = await fetch(url);
  if (!res.ok) throw new Error("weather");
  const data = await res.json();
  const temperature = Math.round(data?.current?.temperature_2m ?? 0);
  const humidity = Math.round(data?.current?.relative_humidity_2m ?? 0);
  const rainfall = Math.round((data?.current?.precipitation ?? 0) * 10) / 10;
  const forecast = rainfall > 0 ? "Rain likely" : temperature > 32 ? "Hot and dry" : "Partly cloudy";
  return { temperature, humidity, rainfall, forecast, localTime: new Date().toLocaleString() };
}

const cropEmojis: Record<string, string> = {
  Wheat: "ЁЯМ╛",
  "Pulses (Lentils)": "ЁЯлШ",
  Soybean: "ЁЯлШ",
  Maize: "ЁЯМ╜",
  Rice: "ЁЯМ┐",
  Cotton: "ЁЯз╡",
  Sugarcane: "ЁЯНм",
  Potato: "ЁЯеФ",
  Groundnut: "ЁЯеЬ",
};

export default function Dashboard() {
  const { isAuthenticated } = useAuth();
  type Language = "en" | "hi" | "ta" | "bn" | "ur" | "kn" | "te" | "ml";
  const [language, setLanguage] = useState<Language>("en");
  const [isListening, setIsListening] = useState(false);
  const [isOffline, setIsOffline] = useState(!navigator.onLine);
  const [hasRequestedRecs, setHasRequestedRecs] = useState(false);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isLocating, setIsLocating] = useState(false);

  // Form state
  const [formData, setFormData] = useState({
    nitrogen: "",
    phosphorus: "",
    potassium: "",
    ph: "",
    soilMoisture: "",
    waterAvailability: "",
    location: "",
  });

  const [recommendations, setRecommendations] = useState(null as null | Array<{
    name: string;
    confidence: number;
    explanation: string;
    profitEstimate: number;
    waterUsage: string;
    fertilizerAdvice: string;
    irrigationAdvice: string;
  }>);
  type WeatherData = {
    temperature: number;
    humidity: number;
    rainfall: number;
    forecast: string;
    localTime?: string;
  };
  const [weatherData, setWeatherData] = useState<WeatherData | null>(null);
  
  const createRecommendation = useMutation(api.recommendations.createRecommendation);
  const userRecommendations = useQuery(api.recommendations.getRecommendations, {});
  // Fetch market prices for the sidebar (kept but we will render custom table)
  const marketPrices = useQuery(api.market.getMarketPrices, {});

  // Language translations (ensure const assertion)
  const translations = {
    en: {
      title: "KisanYatra: AI Crop Recommendation System",
      subtitle: "Get personalized crop recommendations based on your soil data",
      soilData: "Soil Data Input",
      nitrogen: "Nitrogen (N) - kg/ha",
      phosphorus: "Phosphorus (P) - kg/ha",
      potassium: "Potassium (K) - kg/ha",
      ph: "pH Level",
      soilMoisture: "Soil Moisture (%)",
      waterAvailability: "Water Availability (%)",
      location: "Location",
      getRecommendation: "Get Crop Recommendation",
      recommendations: "Recommended Crops",
      marketPrices: "Market Prices",
      weather: "Weather Forecast",
      offline: "You are offline. Using cached data.",
      listening: "Listening...",
      speak: "Speak your input",
      connect: "Connect",
      chat: "Chat",
      contacts: "Contacts",
      enterMessage: "Type a message...",
      shareContact: "Share Contact",
      name: "Name",
      phone: "Phone",
      note: "Note (optional)",
      post: "Post",
      save: "Save",
      stateRoom: "State room",
    },
    hi: {
      title: "KisanYatra: рдПрдЖрдИ рдлрд╕рд▓ рд╕рд┐рдлрд╛рд░рд┐рд╢ рдкреНрд░рдгрд╛рд▓реА",
      subtitle: "рдЕрдкрдиреЗ рдорд┐рдЯреНрдЯреА рдХреЗ рдбреЗрдЯрд╛ рдХреЗ рдЖрдзрд╛рд░ рдкрд░ рд╡реНрдпрдХреНрддрд┐рдЧрдд рдлрд╕рд▓ рд╕рд┐рдлрд╛рд░рд┐рд╢реЗрдВ рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВ",
      soilData: "рдорд┐рдЯреНрдЯреА рдбреЗрдЯрд╛ рдЗрдирдкреБрдЯ",
      nitrogen: "рдирд╛рдЗрдЯреНрд░реЛрдЬрди (N) - рдХрд┐рдЧреНрд░рд╛/рд╣реЗрдХреНрдЯреЗрдпрд░",
      phosphorus: "рдлрд╛рд╕реНрдлреЛрд░рд╕ (P) - рдХрд┐рдЧреНрд░рд╛/рд╣реЗрдХреНрдЯреЗрдпрд░",
      potassium: "рдкреЛрдЯреЗрд╢рд┐рдпрдо (K) - рдХрд┐рдЧреНрд░рд╛/рд╣реЗрдХреНрдЯреЗрдпрд░",
      ph: "рдкреАрдПрдЪ рд╕реНрддрд░",
      soilMoisture: "рдорд┐рдЯреНрдЯреА рдХреА рдирдореА (%)",
      waterAvailability: "рдкрд╛рдиреА рдХреА рдЙрдкрд▓рдмреНрдзрддрд╛ (%)",
      location: "рд╕реНрдерд╛рди",
      getRecommendation: "рдлрд╕рд▓ рд╕рд┐рдлрд╛рд░рд┐рд╢ рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВ",
      recommendations: "рд╕реБрдЭрд╛рдИ рдЧрдИ рдлрд╕рд▓реЗрдВ",
      marketPrices: "рдмрд╛рдЬрд╛рд░ рдореВрд▓реНрдп",
      weather: "рдореМрд╕рдо рдкреВрд░реНрд╡рд╛рдиреБрдорд╛рди",
      offline: "рдЖрдк рдСрдлрд╝рд▓рд╛рдЗрди рд╣реИрдВред рдХреИрд╢реНрдб рдбреЗрдЯрд╛ рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░ рд░рд╣реЗ рд╣реИрдВред",
      listening: "рд╕реБрди рд░рд╣рд╛ рд╣реИ...",
      speak: "рдЕрдкрдирд╛ рдЗрдирдкреБрдЯ рдмреЛрд▓реЗрдВ",
      connect: "рдХрдиреЗрдХреНрдЯ",
      chat: "рдЪреИрдЯ",
      contacts: "рд╕рдВрдкрд░реНрдХ",
      enterMessage: "рд╕рдВрджреЗрд╢ рд▓рд┐рдЦреЗрдВ...",
      shareContact: "рд╕рдВрдкрд░реНрдХ рд╕рд╛рдЭрд╛ рдХрд░реЗрдВ",
      name: "Name",
      phone: "Phone",
      note: "Note (optional)",
      post: "Post",
      save: "Save",
      stateRoom: "State room",
    },
    ta: {
      title: "KisanYatra: роПроР рокропро┐ро░рпН рокро░ро┐роирпНродрпБро░рпИ роЕроорпИрокрпНрокрпБ",
      subtitle: "роЙроЩрпНроХро│рпН роорогрпН родро░ро╡ро┐ройрпН роЕроЯро┐рокрпНрокроЯрпИропро┐ро▓рпН родройро┐рокрпНрокропройрпН рокро░ро┐роирпНродрпБро░рпИроХро│рпН",
      soilData: "роорогрпН родро░ро╡рпБ",
      nitrogen: "роирпИроЯрпНро░роЬройрпН (N) - роХро┐/ро╣рпЖ",
      phosphorus: "рокро╛ро╕рпНрокро░ро╕рпН (P) - роХро┐/ро╣рпЖ",
      potassium: "рокрпКроЯрпНроЯро╛роЪро┐ропроорпН (K) - роХро┐/ро╣рпЖ",
      ph: "pH роиро┐ро▓рпИ",
      soilMoisture: "роорогрпН роИро░рокрпНрокродроорпН (%)",
      waterAvailability: "родрогрпНрогрпАро░рпН роХро┐роЯрпИроХрпНроХрпБроорпН (%)",
      location: "роЗроЯроорпН",
      getRecommendation: "рокро░ро┐роирпНродрпБро░рпИ рокрпЖро▒",
      recommendations: "рокро░ро┐роирпНродрпБро░рпИроХрпНроХрокрпНрокроЯрпНроЯ рокропро┐ро░рпНроХро│рпН",
      marketPrices: "роЪроирпНродрпИ ро╡ро┐ро▓рпИ",
      weather: "ро╡ро╛ройро┐ро▓рпИ",
      offline: "роирпАроЩрпНроХро│рпН роЖроГрокрпНро▓рпИройро┐ро▓рпН роЙро│рпНро│рпАро░рпНроХро│рпН.",
      listening: "роХрпЗроЯрпНроХро┐ро▒родрпБ...",
      speak: "роЙроЩрпНроХро│рпН роЙро│рпНро│рпАроЯрпНроЯрпИ рокрпЗроЪрпБроЩрпНроХро│рпН",
      connect: "роЗрогрпИ",
      chat: "роЕро░роЯрпНроЯрпИ",
      contacts: "родрпКроЯро░рпНрокрпБроХро│рпН",
      enterMessage: "роЪрпЖропрпНродро┐ роОро┤рпБродро╡рпБроорпН...",
      shareContact: "родрпКроЯро░рпНрокрпИ рокроХро┐ро░рпН",
      name: "рокрпЖропро░рпН",
      phone: "рокрпЗроЪро┐",
      note: "Note (optional)",
      post: "Post",
      save: "Save",
      stateRoom: "рооро╛роиро┐ро▓ роЕро▒рпИ",
    },
    bn: {
      title: "KisanYatra: ржПржЖржЗ ржлрж╕рж▓ рж╕рзБржкрж╛рж░рж┐рж╢ ржмрзНржпржмрж╕рзНржерж╛",
      subtitle: "ржорж╛ржЯрж┐рж░ ржбрзЗржЯрж╛рж░ ржЙржкрж░ ржнрж┐рждрзНрждрж┐ ржХрж░рзЗ ржмрзНржпржХрзНрждрж┐ржЧржд рж╕рзБржкрж╛рж░рж┐рж╢",
      soilData: "ржорж╛ржЯрж┐рж░ рждржерзНржп",
      nitrogen: "ржирж╛ржЗржЯрзНрж░рзЛржЬрзЗржи (N) - ржХрзЗржЬрж┐/рж╣рзЗржГ",
      phosphorus: "ржлрж╛рж╕рзНржлрж░рж╛рж╕ (P) - ржХрзЗржЬрж┐/рж╣рзЗржГ",
      potassium: "ржкржЯрж╛рж╢рж┐ржпрж╝рж╛ржо (K) - ржХрзЗржЬрж┐/рж╣рзЗржГ",
      ph: "pH рж╕рзНрждрж░",
      soilMoisture: "ржорж╛ржЯрж┐рж░ ржЖрж░рзНржжрзНрж░рждрж╛ (%)",
      waterAvailability: "ржЬрж▓рзЗрж░ ржкрзНрж░рж╛ржкрзНржпрждрж╛ (%)",
      location: "ржЕржмрж╕рзНржерж╛ржи",
      getRecommendation: "ржлрж╕рж▓ рж╕рзБржкрж╛рж░рж┐рж╢ ржкрж╛ржи",
      recommendations: "ржкрзНрж░рж╕рзНрждрж╛ржмрж┐ржд ржлрж╕рж▓",
      marketPrices: "ржмрж╛ржЬрж╛рж░ ржорзВрж▓рзНржп",
      weather: "ржЖржмрж╣рж╛ржУржпрж╝рж╛",
      offline: "ржЖржкржирж┐ ржЕржлрж▓рж╛ржЗржиред",
      listening: "рж╢рзБржиржЫрзЗ...",
      speak: "ржЖржкржирж╛рж░ ржЗржиржкрзБржЯ ржмрж▓рзБржи",
      connect: "рж╕ржВржпрзБржХрзНржд рж╣рзЛржи",
      chat: "ржЪрзНржпрж╛ржЯ",
      contacts: "ржпрзЛржЧрж╛ржпрзЛржЧ",
      enterMessage: "ржмрж╛рж░рзНрждрж╛ рж▓рж┐ржЦрзБржи...",
      shareContact: "ржпрзЛржЧрж╛ржпрзЛржЧ рж╢рзЗржпрж╝рж╛рж░ ржХрж░рзБржи",
      name: "ржирж╛ржо",
      phone: "ржлрзЛржи",
      note: "ржирзЛржЯ (ржРржЪрзНржЫрж┐ржХ)",
      post: "ржкрзЛрж╕рзНржЯ",
      save: "рж╕ржВрж░ржХрзНрж╖ржг",
      stateRoom: "рж░рж╛ржЬрзНржп ржХржХрзНрж╖",
    },
    ur: {
      title: "KisanYatra: ╪з█Т ╪в╪ж█М ┘Б╪╡┘Д ┌й█М ╪│┘Б╪з╪▒╪┤╪з╪к",
      subtitle: "╪в┘╛ ┌й█М ┘Е┘╣█М ┌й█Т ┌И█М┘╣╪з ┘╛╪▒ ┘Е╪и┘Ж█М ╪░╪з╪к█М ╪│┘Б╪з╪▒╪┤╪з╪к",
      soilData: "┘Е┘╣█М ┌й█Т ┌И█М┘╣╪з",
      nitrogen: "┘Ж╪з╪ж┘╣╪▒┘И╪м┘Ж (N) - ┌й┘Д┘И/█Б█М┌й┘╣╪▒",
      phosphorus: "┘Б╪з╪│┘Б┘И╪▒╪│ (P) - ┌й┘Д┘И/█Б█М┌й┘╣╪▒",
      potassium: "┘╛┘И┘╣╪з╪┤█М┘Е (K) - ┌й┘Д┘И/█Б█М┌й┘╣╪▒",
      ph: "pH ╪│╪╖╪н",
      soilMoisture: "┘Е┘╣█М ┌й█М ┘Ж┘Е█М (%)",
      waterAvailability: "┘╛╪з┘Ж█М ┌й█М ╪п╪│╪к█М╪з╪и█М (%)",
      location: "┘Е┘В╪з┘Е",
      getRecommendation: "┘Б╪╡┘Д ┌й█М ╪│┘Б╪з╪▒╪┤ ╪н╪з╪╡┘Д ┌й╪▒█М┌║",
      recommendations: "╪│┘Б╪з╪▒╪┤ ┌й╪▒╪п█Б ┘Б╪╡┘Д█М┌║",
      marketPrices: "╪и╪з╪▓╪з╪▒ ┘В█М┘Е╪к█М┌║",
      weather: "┘Е┘И╪│┘Е",
      offline: "╪в┘╛ ╪в┘Б ┘Д╪з╪ж┘Ж █Б█М┌║█Ф",
      listening: "╪│┘Ж ╪▒█Б╪з █Б█Т...",
      speak: "╪з┘╛┘Ж╪з ╪з┘Ж ┘╛┘╣ ╪и┘И┘Д█М┌║",
      connect: "╪▒╪з╪и╪╖█Б",
      chat: "┌Ж█М┘╣",
      contacts: "╪▒╪з╪и╪╖█Т",
      enterMessage: "┘╛█М╪║╪з┘Е ┘Д┌й┌╛█М┌║...",
      shareContact: "╪▒╪з╪и╪╖█Б ╪┤█М╪ж╪▒ ┌й╪▒█М┌║",
      name: "┘Ж╪з┘Е",
      phone: "┘Б┘И┘Ж",
      note: "┘Ж┘И┘╣ (╪з╪о╪к█М╪з╪▒█М)",
      post: "┘╛┘И╪│┘╣",
      save: "┘Е╪н┘Б┘И╪╕ ┌й╪▒█М┌║",
      stateRoom: "╪▒█М╪з╪│╪к ┌й┘Е╪▒█Б",
    },
    kn: {
      title: "KisanYatra: р▓Ор▓Р р▓мр│Жр▓│р│Ж р▓╢р▓┐р▓лр▓╛р▓░р▓╕р│Б р▓╡р│Нр▓пр▓╡р▓╕р│Нр▓ер│Ж",
      subtitle: "р▓ир▓┐р▓ор│Нр▓о р▓ор▓гр│Нр▓гр▓┐р▓и р▓бр│Зр▓Яр▓╛ р▓Жр▓зр▓╛р▓░р▓┐р▓д р▓╡р│Ир▓пр▓Хр│Нр▓др▓┐р▓Х р▓╢р▓┐р▓лр▓╛р▓░р▓╕р│Бр▓Чр▓│р│Б",
      soilData: "р▓ор▓гр│Нр▓гр▓┐р▓и р▓бр│Зр▓Яр▓╛",
      nitrogen: "р▓ир│Ир▓Яр│Нр▓░р│Лр▓Ьр▓ир│Н (N) - р▓Хр│Жр▓Ьр▓┐/р▓╣р│Ж",
      phosphorus: "р▓лр▓╛р▓╕р│Нр▓лр▓░р▓╕р│Н (P) - р▓Хр│Жр▓Ьр▓┐/р▓╣р│Ж",
      potassium: "р▓кр│Кр▓Яр▓╛р▓╖р▓┐р▓пр▓В (K) - р▓Хр│Жр▓Ьр▓┐/р▓╣р│Ж",
      ph: "pH р▓ор▓Яр│Нр▓Я",
      soilMoisture: "р▓ор▓гр│Нр▓гр▓┐р▓и р▓др│Зр▓╡р▓╛р▓Вр▓╢ (%)",
      waterAvailability: "р▓ир│Ар▓░р│Б р▓▓р▓нр│Нр▓пр▓др│Ж (%)",
      location: "р▓╕р│Нр▓ер▓│",
      getRecommendation: "р▓мр│Жр▓│р│Ж р▓╢р▓┐р▓лр▓╛р▓░р▓╕р│Б р▓кр▓бр│Жр▓пр▓┐р▓░р▓┐",
      recommendations: "р▓╢р▓┐р▓лр▓╛р▓░р▓╕р│Б р▓ор▓╛р▓бр▓┐р▓ж р▓мр│Жр▓│р│Жр▓Чр▓│р│Б",
      marketPrices: "р▓ор▓╛р▓░р│Бр▓Хр▓Яр│Нр▓Яр│Ж р▓мр│Жр▓▓р│Жр▓Чр▓│р│Б",
      weather: "р▓Хр▓╛р▓▓р▓╛р▓╡р▓╕р│Нр▓е",
      offline: "р▓ир│Ар▓╡р│Б р▓Жр▓лр│НтАМр▓▓р│Ир▓ир│НтАМ р▓Зр▓жр│Нр▓жр│Ар▓░р▓┐.",
      listening: "р▓Хр│Жр▓│р│Бр▓др│Нр▓др▓┐р▓жр│Ж...",
      speak: "р▓ир▓┐р▓ор│Нр▓о р▓Зр▓ир│НтАМinpр│Бр▓Яр│Н р▓ор▓╛р▓др▓ир▓╛р▓бр▓┐",
      connect: "р▓Хр▓ир│Жр▓Хр│Нр▓Яр│Н",
      chat: "р▓Ър▓╛р▓Яр│Н",
      contacts: "р▓╕р▓Вр▓кр▓░р│Нр▓Хр▓Чр▓│р│Б",
      enterMessage: "р▓╕р▓Вр▓жр│Зр▓╢р▓╡р▓ир│Нр▓ир│Б р▓мр▓░р│Жр▓пр▓┐р▓░р▓┐...",
      shareContact: "р▓╕р▓Вр▓кр▓░р│Нр▓Хр▓╛р▓ир│Нр▓ир▓┐ р┤кр┤Щр╡Нр┤Хр┤┐р┤Яр╡Бр┤Х",
      name: "р▓╣р│Жр▓╕р▓░р│Б",
      phone: "р▓лр│Лр▓ир│Н",
      note: "р▓Чр▓ор▓ир▓┐р▓Х (р▓Рр▓Ър│Нр▓Ыр▓┐р▓Хр▓В)",
      post: "р┤кр╡Лр┤╕р╡Нр┤▒р╡Нр┤▒р╡Н",
      save: "р▓Йр▓│р▓┐р▓╕р▓┐",
      stateRoom: "р▓░р▓╛р▓Ьр│Нр▓п р▓Хр│Кр▓ар▓бр▓┐",
    },
    te: {
      title: "KisanYatra: р░Пр░Р р░кр░Вр░Я р░╕р░┐р░лр░╛р░░р▒Нр░╕р▒Б р░╡р▒Нр░пр░╡р░╕р▒Нр░д",
      subtitle: "р░ор▒А р░ир▒Зр░▓ р░бр▒Зр░Яр░╛ р░Жр░зр░╛р░░р░Вр░Чр░╛ р░╡р▒Нр░пр░Хр▒Нр░др░┐р░Чр░д р░╕р░┐р░лр░╛р░░р▒Нр░╕р▒Бр░▓р▒Б",
      soilData: "р░ир▒Зр░▓ р░бр▒Зр░Яр░╛",
      nitrogen: "р░ир▒Ир░Яр▒Нр░░р▒Лр░Ьр░ир▒Н (N) - р░Хр▒Зр░Ьр▒А/р░╣р▒Ж",
      phosphorus: "р░лр░╛р░╕р▒Нр░лр░░р░╕р▒Н (P) - р░Хр▒Зр░Ьр▒А/р░╣р▒Ж",
      potassium: "р░кр▒Кр░Яр░╛р░╖р░┐р░пр░В (K) - р░Хр▒Зр░Ьр▒А/р░╣р▒Ж",
      ph: "pH р░╕р▒Нр░ер░╛р░пр░┐",
      soilMoisture: "р░ир▒Зр░▓ р░др▒Зр░о (%)",
      waterAvailability: "р░ир▒Ар░Яр░┐ р░▓р░нр▒Нр░пр░д (%)",
      location: "р░╕р▒Ня┐╜р░╛р░ир░В",
      getRecommendation: "р░кр░Вр░Я р░╕р░┐р░лр░╛р░░р▒Нр░╕р▒Б р░кр▒Кр░Вр░жр░Вр░бр░┐",
      recommendations: "р░╕р░┐р░лр░╛р░░р░╕р▒Б р░Ър▒Зр░╕р░┐р░и р░кр░Вр░Яр░▓р▒Б",
      marketPrices: "р░ор░╛р░░р▒Бр░Хр▓Яр▒Нр░Яр▒Ж р░мр▒Жр░▓р▒Жр░Чр░│р▒Б",
      weather: "р░╡р░╛р░др░╛р░╡р░░р░гр░В",
      offline: "р░ор▒Ар░░р▒Б р░Жр░лр▒НтАМр░▓р▒Ир░ир▒НтАМр░▓р▒Л р░Йр░ир▒Нр░ир░╛р░░р▒Б.",
      listening: "р░╡р░┐р░Вр░Яр▒Лр░Вр░жр░┐...",
      speak: "р░ор▒А р░Зр░ир▒НтАМр░кр▒Бр░Яр▒Н р░ор░╛р░Яр▒Нр░▓р░╛р░бр░Вр░бр░┐",
      connect: "р░Хр░ир▒Жр░Хр▒Нр░Яр▒Н",
      chat: "р░Ър░╛р░Яр▒Н",
      contacts: "р░╕р░Вр░кр░░р▒Нр░Хр░╛р░▓р▒Б",
      enterMessage: "р░╕р░Вр░жр▒Зр░╢р░В р░Яр▒Ир░кр▒Н р░Ър▒Зр░пр░Вр░бр░┐...",
      shareContact: "р░╕р░Вр░кр░░р▒Нр░Хр░╛р░ир▒Нр░ир░┐ р░кр░Вр░Ър▒Бр░Хр▒Лр░Вр░бр░┐",
      name: "р░кр▒Зр░░р▒Б",
      phone: "р░лр▒Лр░ир▒Н",
      note: "р░Чр░ор░ир░┐р░Х (р░Рр░Ър▒Нр░Ър░┐р░Хр░В)",
      post: "р░кр▒Лр░╕р▒Нр░Яр▒Н",
      save: "р░╕р▒Зр░╡р▒Н",
      stateRoom: "р░░р░╛р░╖р▒Нр░Яр▒Нр░░ р░Чр░жр░┐",
    },
    ml: {
      title: "KisanYatra: р┤Ор┤Р р┤╡р┤┐р┤│ р┤╢р╡Бр┤кр┤╛р╡╝р┤╢ р┤╕р┤Вр┤╡р┤┐р┤зр┤╛р┤ир┤В",
      subtitle: "р┤ир┤┐р┤Щр╡Нр┤Щр┤│р╡Бр┤Яр╡Ж р┤ор┤гр╡Нр┤гр╡Н р┤бр┤╛р┤▒р╡Нр┤▒р┤пр╡Ж р┤Ер┤Яр┤┐р┤╕р╡Нр┤ер┤╛р┤ир┤ор┤╛р┤Хр╡Нр┤Хр┤┐ р┤╡р╡Нр┤пр┤Хр╡Нр┤др┤┐р┤Чр┤д р┤╡р┤┐р┤│ р┤╢р╡Бр┤кр┤╛р╡╝р┤╢р┤Хр╡╛ р┤ир╡Зр┤Яр╡Бр┤Х",
      soilData: "р┤ор┤гр╡Нр┤гр╡Н р┤бр┤╛р┤▒р╡Нр┤▒ р┤Зр╡╗р┤кр╡Бр┤Яр╡Нр┤Яр╡Н",
      nitrogen: "р┤ир╡Ир┤Яр╡Нр┤░р┤Ьр╡╗ (N) - kg/ha",
      phosphorus: "р┤лр╡Лр┤╕р╡Нр┤лр┤▒р┤╕р╡Н (P) - kg/ha",
      potassium: "р┤кр╡Кр┤Яр╡Нр┤Яр┤╛р┤╖р╡Нр┤пр┤В (K) - kg/ha",
      ph: "pH р┤ир┤┐р┤▓",
      soilMoisture: "р┤ор┤гр╡Нр┤гр┤┐р┤▓р╡Ж р┤Ир╡╝р┤кр╡Нр┤кр┤В (%)",
      waterAvailability: "р┤Ьр┤▓ р┤▓р┤нр╡Нр┤пр┤д (%)",
      location: "р┤╕р╡Нр┤ер┤╛р┤ир┤В",
      getRecommendation: "р┤╡р┤┐р┤│ р┤╢р╡Бр┤кр┤╛р╡╝р┤╢ р┤▓р┤нр┤┐р┤Хр╡Нр┤Хр╡Бр┤Х",
      recommendations: "р┤╢р╡Бр┤кр┤╛р╡╝р┤╢ р┤Ър╡Жр┤пр╡Нр┤пр╡Бр┤ир╡Нр┤и р┤╡р┤┐р┤│р┤Хр╡╛",
      marketPrices: "р┤ор┤╛р╡╝р┤Хр╡Нр┤Хр┤▒р╡Нр┤▒р╡Н р┤╡р┤┐р┤▓р┤Хр╡╛",
      weather: "р┤Хр┤╛р┤▓р┤╛р┤╡р┤╕р╡Нр┤е",
      offline: "р┤ир┤┐╠Бр┤Щр╡Нр┤Щр╡╛ р┤Ур┤лр╡НтАМр┤▓р╡Ир╡╗ р┤Жр┤гр╡Н. р┤Хр┤╛р┤╖р╡Ж р┤Ър╡Жр┤пр╡Нр┤д р┤бр┤╛р┤▒р╡Нр┤▒ р┤Йр┤кр┤пр╡Лр┤Чр┤┐р┤Хр╡Нр┤Хр╡Бр┤ир╡Нр┤ир╡Б.",
      listening: "р┤Хр╡Зр╡╛р┤Хр╡Нр┤Хр╡Бр┤ир╡Нр┤ир╡Б...",
      speak: "р┤ир┤┐р┤Щр╡Нр┤Щр┤│р╡Бр┤Яр╡Ж р┤Зр╡╗р┤кр╡Бр┤Яр╡Нр┤Яр╡Н р┤╕р┤Вр┤╕р┤╛р┤░р┤┐р┤Хр╡Нр┤Хр╡Бр┤Х",
      connect: "р┤Хр┤гр┤Хр╡Нр┤▒р╡Нр┤▒р╡Н",
      chat: "р┤Ър┤╛р┤▒р╡Нр┤▒р╡Н",
      contacts: "р┤╕р┤Вр┤кр┤░р╡Нр┤Хр┤Чр┤│р╡Б",
      enterMessage: "р┤╕р┤ир╡Нр┤жр╡Зр┤╢р┤В р┤Яр╡Ир┤кр╡Нр┤кр╡Н р┤Ър╡Жр┤пр╡Нр┤пр╡Бр┤Х...",
      shareContact: "р┤╕р┤Вр┤кр┤░р╡Нр┤Хр┤╛р┤ир╡Нр┤ир┤┐ р┤кр┤Щр╡Нр┤Хр┤┐р┤Яр╡Бр┤Х",
      name: "р┤кр╡Зр┤░р╡Н",
      phone: "р┤лр╡Лр┤гр╡НтАН",
      note: "р┤Чр┤ор┤ир┤┐р┤Х (р┤Рр┤Ър╡Нр┤Ыр┤┐р┤Хр┤В)",
      post: "р┤кр╡Лр┤╕р╡Нр┤▒р╡Нр┤▒р╡Н",
      save: "р┤╕р╡Зр┤╡р╡Н",
      stateRoom: "р┤╕р╡Нр┤▒р╡Нр┤▒р╡Зр┤▒р╡Нр┤▒р╡Н р┤▒р╡Вр┤В",
    },
  } as const;

  const t = translations[language];

  // Removed local dark mode toggle; using global top-right toggle app-wide

  // Offline detection
  useEffect(() => {
    const handleOnline = () => setIsOffline(false);
    const handleOffline = () => setIsOffline(true);
    
    window.addEventListener("online", handleOnline);
    window.addEventListener("offline", handleOffline);
    
    return () => {
      window.removeEventListener("online", handleOnline);
      window.removeEventListener("offline", handleOffline);
    };
  }, []);

  // Enhance geolocation with permission handling, reverse geocoding (optional), and accurate weather
  const getCurrentLocation = async () => {
    try {
      setIsLocating(true);
      // @ts-ignore
      if (navigator.permissions && navigator.permissions.query) {
        // @ts-ignore
        const status = await navigator.permissions.query({ name: "geolocation" });
        if (status.state === "denied") {
          toast.error("Location permission denied. Please allow location access in browser settings.");
          setIsLocating(false);
          return;
        }
      }
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          async (position) => {
            const { latitude, longitude } = position.coords;
            // Try reverse geocoding via Google if key exists
            let pretty = `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
            const key = (import.meta as any).env?.VITE_GOOGLE_MAPS_API_KEY as string | undefined;
            try {
              if (key) {
                const resp = await fetch(
                  `https://maps.googleapis.com/maps/api/geocode/json?latlng=${latitude},${longitude}&key=${key}`,
                );
                const gj = await resp.json();
                const comp = gj?.results?.[0]?.address_components as Array<any> | undefined;
                if (comp) {
                  const city = comp.find((c) => c.types.includes("locality"))?.long_name;
                  const state = comp.find((c) => c.types.includes("administrative_area_level_1"))?.long_name;
                  if (city || state) pretty = [city, state].filter(Boolean).join(", ");
                }
              }
            } catch {
              // silent fallback to coords string
            }

            setFormData((prev) => ({ ...prev, location: pretty }));

            try {
              const w = await fetchWeather(latitude, longitude);
              setWeatherData(w);
            } catch {
              setWeatherData(deriveWeatherFromLocation(pretty));
            }
            toast.success("Location detected successfully!");
            setIsLocating(false);
          },
          () => {
            toast.error("Unable to get location automatically. Please enter location manually.");
            setIsLocating(false);
          },
          { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 },
        );
      } else {
        toast.error("Geolocation not supported by this browser.");
        setIsLocating(false);
      }
    } catch {
      toast.error("Location access error. Please enter manually.");
      setIsLocating(false);
    }
  };

  // Speech recognition
  const startListening = () => {
    const w = window as unknown as {
      webkitSpeechRecognition?: any;
      SpeechRecognition?: any;
    };
    if ('webkitSpeechRecognition' in w || 'SpeechRecognition' in w) {
      const SpeechRecognition = w.webkitSpeechRecognition || w.SpeechRecognition;
      const recognition = new SpeechRecognition();
      
      recognition.lang = language === 'hi' ? 'hi-IN' : 'en-US';
      recognition.continuous = false;
      recognition.interimResults = false;
      
      recognition.onstart = () => {
        setIsListening(true);
        toast.info(t.listening);
      };
      
      recognition.onresult = (event: any) => {
        const transcript = event.results[0][0].transcript as string;
        // Simple parsing for demo - in production, use NLP
        if (transcript.toLowerCase().includes('nitrogen')) {
          const match = transcript.match(/\d+/);
          if (match) {
            setFormData(prev => ({ ...prev, nitrogen: match[0] }));
          }
        }
        toast.success(`Heard: ${transcript}`);
      };
      
      recognition.onerror = () => {
        toast.error("Speech recognition error");
        setIsListening(false);
      };
      
      recognition.onend = () => {
        setIsListening(false);
      };
      
      recognition.start();
    } else {
      toast.error("Speech recognition not supported");
    }
  };

  // Text to speech
  const speakText = (text: string) => {
    if ('speechSynthesis' in window) {
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = language === 'hi' ? 'hi-IN' : 'en-US';
      speechSynthesis.speak(utterance);
    }
  };

  // Handle form submission
  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsSubmitting(true);
    try {
      const result = await createRecommendation({
        nitrogen: parseFloat(formData.nitrogen),
        phosphorus: parseFloat(formData.phosphorus),
        potassium: parseFloat(formData.potassium),
        ph: parseFloat(formData.ph),
        soilMoisture: parseFloat(formData.soilMoisture),
        waterAvailability: parseFloat(formData.waterAvailability),
        location: formData.location,
      });

      const recs = (result as any).recommendedCrops as typeof recommendations;
      setRecommendations(recs);
      setHasRequestedRecs(true);

      if (Array.isArray(recs) && recs.length === 0) {
        toast.message("No exact matches found. Showing best-fit suggestions.");
      } else {
        toast.success("Crop recommendations generated!");
      }

      // Derive weather based on the submitted location for variability
      if (formData.location) {
        setWeatherData(deriveWeatherFromLocation(formData.location));
      }
      
    } catch (error) {
      toast.error("Failed to generate recommendations");
    } finally {
      setIsSubmitting(false);
    }
  };

  if (!isAuthenticated) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <Card className="w-96">
          <CardHeader>
            <CardTitle>Authentication Required</CardTitle>
            <CardDescription>Please sign in to access the crop recommendation system.</CardDescription>
          </CardHeader>
        </Card>
      </div>
    );
  }

  return (
    <div className={`min-h-screen bg-background transition-colors duration-300`}>
      {/* Header */}
      <header className="border-b bg-card/50 backdrop-blur-sm sticky top-0 z-50">
        <div className="container mx-auto px-4 py-4 pr-56 md:pr-72">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <Leaf className="h-8 w-8 text-green-600" />
              <div>
                <h1 className="text-xl font-bold tracking-tight">KisanYatra: AI Crop Recommendation System</h1>
                <p className="text-sm text-muted-foreground">{t.subtitle}</p>
              </div>
            </div>
            
            <div className="flex items-center gap-3 md:gap-4">
              {/* Add top-level Connect navigation button */}
              <Button
                variant="outline"
                onClick={() => (window.location.href = "/connect")}
                className="hidden sm:inline-flex"
                disabled={isSubmitting || isLocating}
              >
                {t.connect}
              </Button>
              {/* Language Toggle */}
              <Select value={language} onValueChange={(val) => setLanguage(val as Language)}>
                <SelectTrigger className="w-20 sm:w-24 rounded-full px-2">
                  <Globe className="h-4 w-4" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="en">EN</SelectItem>
                  <SelectItem value="hi">рд╣рд┐</SelectItem>
                  <SelectItem value="ta">TA</SelectItem>
                  <SelectItem value="bn">BN</SelectItem>
                  <SelectItem value="ur">UR</SelectItem>
                  <SelectItem value="kn">KN</SelectItem>
                  <SelectItem value="te">TE</SelectItem>
                  <SelectItem value="ml">ML</SelectItem>
                </SelectContent>
              </Select>
              
              {/* Dark mode toggle removed in favor of global toggle */}
            </div>
          </div>
        </div>
      </header>

      {/* Offline Banner */}
      {isOffline && (
        <div className="bg-orange-500 text-white px-4 py-2 text-center text-sm">
          {t.offline}
        </div>
      )}

      <div className="container mx-auto px-4 py-8 max-w-7xl">
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
          {/* Input Form */}
          <div className="lg:col-span-2">
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.5 }}
            >
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Wheat className="h-5 w-5" />
                    {t.soilData}
                  </CardTitle>
                  <CardDescription>
                    Enter your soil parameters to get personalized crop recommendations
                  </CardDescription>
                </CardHeader>
                <CardContent>
                  <form onSubmit={handleSubmit} className="space-y-6">
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      <div className="space-y-2">
                        <Label htmlFor="nitrogen">{t.nitrogen}</Label>
                        <Input
                          id="nitrogen"
                          type="number"
                          placeholder="0-100"
                          value={formData.nitrogen}
                          onChange={(e) => setFormData(prev => ({ ...prev, nitrogen: e.target.value }))}
                          required
                        />
                      </div>
                      
                      <div className="space-y-2">
                        <Label htmlFor="phosphorus">{t.phosphorus}</Label>
                        <Input
                          id="phosphorus"
                          type="number"
                          placeholder="0-100"
                          value={formData.phosphorus}
                          onChange={(e) => setFormData(prev => ({ ...prev, phosphorus: e.target.value }))}
                          required
                        />
                      </div>
                      
                      <div className="space-y-2">
                        <Label htmlFor="potassium">{t.potassium}</Label>
                        <Input
                          id="potassium"
                          type="number"
                          placeholder="0-100"
                          value={formData.potassium}
                          onChange={(e) => setFormData(prev => ({ ...prev, potassium: e.target.value }))}
                          required
                        />
                      </div>
                      
                      <div className="space-y-2">
                        <Label htmlFor="ph">{t.ph}</Label>
                        <Input
                          id="ph"
                          type="number"
                          step="0.1"
                          placeholder="0-14"
                          value={formData.ph}
                          onChange={(e) => setFormData(prev => ({ ...prev, ph: e.target.value }))}
                          required
                        />
                      </div>
                      
                      <div className="space-y-2">
                        <Label htmlFor="soilMoisture">{t.soilMoisture}</Label>
                        <Input
                          id="soilMoisture"
                          type="number"
                          placeholder="0-100"
                          value={formData.soilMoisture}
                          onChange={(e) => setFormData(prev => ({ ...prev, soilMoisture: e.target.value }))}
                          required
                        />
                      </div>
                      
                      <div className="space-y-2">
                        <Label htmlFor="waterAvailability">{t.waterAvailability}</Label>
                        <Input
                          id="waterAvailability"
                          type="number"
                          placeholder="0-100"
                          value={formData.waterAvailability}
                          onChange={(e) => setFormData(prev => ({ ...prev, waterAvailability: e.target.value }))}
                          required
                        />
                      </div>
                    </div>
                    
                    <div className="space-y-2">
                      <Label htmlFor="location">{t.location}</Label>
                      <div className="flex gap-2">
                        <Input
                          id="location"
                          placeholder="Enter location or use GPS"
                          value={formData.location}
                          onChange={(e) => setFormData(prev => ({ ...prev, location: e.target.value }))}
                          required
                          inputMode="text"
                        />
                        <Button type="button" variant="outline" onClick={getCurrentLocation} disabled={isLocating}>
                          {isLocating ? (
                            <Loader2 className="h-4 w-4 animate-spin" />
                          ) : (
                            <MapPin className="h-4 w-4" />
                          )}
                        </Button>
                      </div>
                    </div>
                    
                    <div className="flex gap-2">
                      <Button type="submit" className="flex-1" disabled={isSubmitting}>
                        {isSubmitting ? (
                          <>
                            <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                            Generating...
                          </>
                        ) : (
                          t.getRecommendation
                        )}
                      </Button>
                      <Button
                        type="button"
                        variant="outline"
                        onClick={startListening}
                        disabled={isListening || isSubmitting || isLocating}
                        aria-busy={isListening}
                      >
                        {isListening ? <MicOff className="h-4 w-4" /> : <Mic className="h-4 w-4" />}
                      </Button>
                    </div>
                  </form>
                </CardContent>
              </Card>
            </motion.div>
          </div>

          {/* Sidebar */}
          <div className="space-y-6">
            {/* Weather Card */}
            <motion.div
              initial={{ opacity: 0, x: 20 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ duration: 0.5, delay: 0.1 }}
            >
              <WeatherCard t={t} weatherData={weatherData} />
            </motion.div>

            {/* Market Prices (formatted table, last updated: Today) */}
            <motion.div
              initial={{ opacity: 0, x: 20 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ duration: 0.5, delay: 0.2 }}
            >
              <MarketPricesCard t={t as any} cropEmojis={cropEmojis} />
            </motion.div>
          </div>
        </div>

        {/* Recommendations Results */}
        {hasRequestedRecs && ((recommendations && recommendations.length > 0) || (userRecommendations && userRecommendations.length > 0)) && (
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5, delay: 0.3 }}
            className="mt-8"
          >
            <RecommendationsList
              t={t as any}
              cropEmojis={cropEmojis}
              recommendations={recommendations}
              userRecommendations={userRecommendations}
              speakText={speakText}
            />
          </motion.div>
        )}

        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5, delay: 0.35 }}
          className="mt-8"
        >
          {/* ConnectSection moved to dedicated page */}
        </motion.div>
      </div>
    </div>
  );
}